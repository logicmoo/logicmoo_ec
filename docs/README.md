````bash
wget https://fai.cs.uni-saarland.de/hoffmann/papers/ai05.pdf
pdftotext ai05.pdf -layout "ai05.pdf.txt"
cp /opt/logicmoo_workspace/packs_usr/old_logicmoo_workspace/pack/logicmoo_planner/pddl/uw-yale-pddl/doc/pddl.tex .
cp /opt/logicmoo_workspace/packs_usr/old_logicmoo_workspace/pack/logicmoo_planner/prolog/logicmoo/planner/tesis/Tesis/cap2.tex .
ps2txt /opt/logicmoo_workspace/packs_usr/old_logicmoo_workspace/pack/logicmoo_planner/prolog/logicmoo/planform-website/kbcs00.ps > kbcs00.ps.txt
pdftotext "/opt/logicmoo_workspace/packs_usr/old_logicmoo_workspace/pack/logicmoo_planner/prolog/logicmoo/Papers/P9VFFI~0.PDF" -layout "P9VFFI~0.PDF.txt"
pdftotext "/opt/logicmoo_workspace/packs_usr/old_logicmoo_workspace/pack/logicmoo_planner/prolog/logicmoo/Papers/PDDL 2.1.pdf" -layout "PDDL 2.1.pdf.txt"
pdftotext "/opt/logicmoo_workspace/packs_usr/old_logicmoo_workspace/pack/logicmoo_planner/prolog/logicmoo/Papers/PDDL opt-manual.pdf" -layout "PDDL opt-manual.pdf.txt"
````

/opt/logicmoo_workspace/packs_usr/old_logicmoo_workspace/pack/logicmoo_planner/pddl/benchmarks/psr-large/domain.pddl
/opt/logicmoo_workspace/packs_usr/old_logicmoo_workspace/pack/logicmoo_planner/pddl/benchmarks/psr-middle/domain.pddl
/opt/logicmoo_workspace/packs_usr/old_logicmoo_workspace/pack/logicmoo_planner/prolog/logicmoo/planner/teps/test_suites/translator-files/ZenoTravel/zeon_p5_dp.pddl
/opt/logicmoo_workspace/packs_usr/old_logicmoo_workspace/pack/logicmoo_planner/prolog/logicmoo/planner/teps/test_suites/translator-files/ZenoTravel/zeon_p8_dp.pddl
/opt/logicmoo_workspace/packs_usr/old_logicmoo_workspace/pack/logicmoo_planner/prolog/logicmoo/planner/teps/test_suites/translator-files/ZenoTravel/zeon_p9_dp.pddl
/opt/logicmoo_workspace/packs_usr/old_logicmoo_workspace/pack/logicmoo_planner/pddl/elearning/domain.pddl
/opt/logicmoo_workspace/packs_usr/old_logicmoo_workspace/pack/logicmoo_planner/pddl/failing_or_too_slow/sdom2.htn
/opt/logicmoo_workspace/packs_usr/old_logicmoo_workspace/pack/logicmoo_planner/pddl/failing_or_too_slow/sdom3.htn
/opt/logicmoo_workspace/packs_usr/old_logicmoo_workspace/pack/logicmoo_planner/pddl/failing_or_too_slow/translog4A_w_tasks.htn


/opt/logicmoo_workspace/packs_usr/old_logicmoo_workspace/pack/logicmoo_planner/pddl/domains_ocl/translog.ocl
/opt/logicmoo_workspace/packs_usr/old_logicmoo_workspace/pack/logicmoo_planner/pddl/hsp2_1_0_pddl/planner/parser.y
/opt/logicmoo_workspace/packs_usr/old_logicmoo_workspace/pack/logicmoo_planner/pddl/uw-yale-pddl/src/builtins.lisp

/opt/logicmoo_workspace/packs_usr/old_logicmoo_workspace/pack/logicmoo_planner/prolog/logicmoo/planform-website/gipo_install/jplan/pddl/pddlDomain.java
/opt/logicmoo_workspace/packs_usr/old_logicmoo_workspace/pack/logicmoo_planner/prolog/logicmoo/planform-website/gipo_install/jplan/pddl/pddlOperator.java
/opt/logicmoo_workspace/packs_usr/old_logicmoo_workspace/pack/logicmoo_planner/prolog/logicmoo/planform-website/gipo_install/jplan/pddl/pddlPredicate.java
/opt/logicmoo_workspace/packs_usr/old_logicmoo_workspace/pack/logicmoo_planner/prolog/logicmoo/planform-website/gipo_install/jplan/tools/lifeHist/PropertyDialog.java


/opt/logicmoo_workspace/packs_usr/old_logicmoo_workspace/pack/logicmoo_planner/prolog/logicmoo/planform-website/gipo_install/sp311/library/clpb.pl
/opt/logicmoo_workspace/packs_usr/old_logicmoo_workspace/pack/logicmoo_planner/prolog/logicmoo/planner/golog/golog_swi.pl
/opt/logicmoo_workspace/packs_usr/old_logicmoo_workspace/pack/logicmoo_planner/prolog/logicmoo/planner/golog/Main/golog.pl
/opt/logicmoo_workspace/packs_usr/old_logicmoo_workspace/pack/logicmoo_planner/prolog/logicmoo/planner/misc_planner/bprove.pl
/opt/logicmoo_workspace/packs_usr/old_logicmoo_workspace/pack/logicmoo_planner/prolog/logicmoo/planner/misc_planner/delrob_sitc.pl

/opt/logicmoo_workspace/packs_usr/old_logicmoo_workspace/pack/val/include/val/Analyser.h
/opt/logicmoo_workspace/packs_usr/old_logicmoo_workspace/pack/val/include/val/DYNATranslator.h
/opt/logicmoo_workspace/packs_usr/old_logicmoo_workspace/pack/val/include/val/Exceptions.h
/opt/logicmoo_workspace/packs_usr/old_logicmoo_workspace/pack/val/include/val/FlexLexer.h
/opt/logicmoo_workspace/packs_usr/old_logicmoo_workspace/pack/val/include/val/LPGPTranslator.h
/opt/logicmoo_workspace/packs_usr/old_logicmoo_workspace/pack/val/include/val/Proposition.h
/opt/logicmoo_workspace/packs_usr/old_logicmoo_workspace/pack/val/include/val/ptree.h
/opt/logicmoo_workspace/packs_usr/old_logicmoo_workspace/pack/val/include/val/RelaxTranslator.h
/opt/logicmoo_workspace/packs_usr/old_logicmoo_workspace/pack/val/include/val/TrajectoryConstraints.h
/opt/logicmoo_workspace/packs_usr/old_logicmoo_workspace/pack/val/src/pddl+.yacc
/opt/logicmoo_workspace/packs_usr/old_logicmoo_workspace/pack/val/src/pddl+.lex
/opt/logicmoo_workspace/packs_usr/old_logicmoo_workspace/pack/val/src/val/Events.cpp
/opt/logicmoo_workspace/packs_usr/old_logicmoo_workspace/pack/val/src/val/pddlplus.cpp
/opt/logicmoo_workspace/packs_usr/old_logicmoo_workspace/pack/val/src/val/Proposition.cpp
/opt/logicmoo_workspace/packs_usr/old_logicmoo_workspace/pack/val/src/val/ptree.cpp
/opt/logicmoo_workspace/packs_usr/old_logicmoo_workspace/pack/val/src/val/Relax.cpp
/opt/logicmoo_workspace/packs_usr/old_logicmoo_workspace/pack/val/src/val/State.cpp
/opt/logicmoo_workspace/packs_usr/old_logicmoo_workspace/pack/val/src/val/TypeStrip.cpp
/opt/logicmoo_workspace/packs_usr/old_logicmoo_workspace/pack/val/src/val/Validator.cpp
/opt/logicmoo_workspace/packs_usr/old_logicmoo_workspace/pack/val/src/validate.cpp


``` `

compares(Op):-member(Op,[<,>,=,'=..','=:=',=<,==,=@=,=\=,>=,>=,@<,@=.@>,@>=,\=,\==,\=@=,^]).

io_ops(Op):-member((Op/_),[write/1,disp/1,display/1,post/1,writeq/1,say/1,print/1,
				printf/1]),!.

db_preds(Op):-member((Op/_),[abolish/1,abolish/2,assert/1,assert/2,asserta/1,asserta/2,
				assertz/1,assertz/2]).

fs_preds(Op):-member((Op/_),[absolute_file_name/2,absolute_file_name/3,access_file/2,
				append/1]).

lists(Op):-member((Op/_),[append/3]).

meta(Op):-member((Op/_),[apply/2]).

unused(Op):-member((Op/_),[apropos/1,prolog/0]).
must_be_bound_ops(Op):-io_ops(Op),!.
must_be_bound_ops(Op):-member((Op/_),[not/1,call/1,bound/1,nonvar/1,integer/1]),!.

/*
to_do_once(Where,Who,P_Answer_Atom)),
	write_debug(trace,stacking(Where,Who,P_Answer_Atom)).
*/


	/* this predicate is for 99% parsing goals */
atom_to_prolog(P_Answer_Atom,P_Answer,Vars):-
        /* Convert P_Answer_Atom to P_Answer, */
        /* catch will find U_P_Answer and FreeVars */
        catch(
                /* Parse Atom to U_P_Answere Term */
                atom_to_term(P_Answer_Atom,P_Answer,Vars),

                /* It will auto-break out here if our simple parse worked */
                _Skip_AnyErrors,
                (
                        /* we now must execute a pre-parser on P_Answer_Atom */
                        catch((
                        lets_try_new_syntax(P_Answer_Atom,P_Answer),

                        /* It Worked, now lets get Vars */
                        atom_to_term(_Useless,P_Answer,Vars)),_,fail)
                )
             ).
	/* one of the above Created P_Answer and Vars */
my_prolog(P_Answer_Atom):-!,
	
	/* Do we need to convert this to a term? */
	once(my_atom_to_term(P_Answer_Atom,P_Answer,Vars)),

	/* now we will "compile it"... (make a token langage) */
	
	/* Lets attempt to save our variables as they are now... */
	/* we will overwirite any previos settings */
	unify_Globals(Vars),

	/* write to trace */
	trial(P_Answer,Vars),

	write_debug(trace,
		[attempting,term(P_Answer_Atom,P_Answer,Vars)]),
	
	call_with_depth_limit(once(attempt(P_Answer,Vars)),40,_).

	/* Attempt to execute P_Answer if it executes all is well.. */
	/* it will prove we have adaquate data in the system.. */
	/* Honestly all we hope for Is some varibles will get instantiated */
	/* if none do thats ok, the system is made to handle it (It's Prolog!)*/
	
	
	/* this attempt is actaully to plant the trunk of our "proof tree" */
	/* the ';true' means "OR it is TRUE that some case exists..." */
	/* So if absolutley nothing has been found to work.. P_Answere */
	/* may have just been a generaliztion of what we already know */

:-multifile(attempt/2).
:-multifile(trial/2).

attempt(true,_Vars):-!.

attempt(prolog,_Vars):-!.
attempt(Unbound,_Vars):-not(nonvar(Unbound)),!.

attempt((GoalA,GoalB),Vars):-!,
	attempt(GoalA,Vars),attempt(GoalB,Vars).

trial((GoalA,GoalB),_Vars):-
        trial(GoalA,_Vars),trial(GoalB,_Vars).

attempt((GoalA;GoalB),Vars):-!,
        attempt(GoalA,Vars);attempt(GoalB,Vars).

trial((GoalA;GoalB),_Vars):-
        trial(GoalA,_Vars);trial(GoalB,_Vars).

attempt((GoalA:-GoalB),_Vars):-!,create_new_clause((GoalA:-GoalB)).

trial((_GoalA:-_GoalB),_Vars):-true.

attempt(assert(GoalA:-GoalB),_Vars):-!,create_new_clause((GoalA:-GoalB)).
attempt(assert(Data),_Vars):-!,create_new_clause((Data:-true)).

trial(assert(_),_Vars):-true.

create_new_clause((Head:-Body)):-!,
	not(Head=Body),
	not(clause(Body,Head)),
	assert((Head:-Body)),
	write_debug(trace,asserted((Head:-Body))).

attempt(display(Output),_Vars):-!,term_to_string(Output,Post),post(Post).
attempt(WriteOutput,_Vars):-
	WriteOutput=..[Write|Output],
	member(Write,[write,output,post,writeq,say,print,printf]),!,
	write_debug(trace,output(Output)),
	post(Output).

trial(WriteOutput,_Vars):-
        WriteOutput=..[Write|Output],
        member(Write,[write,disp,display,post,writeq,say,print,printf]),!,
        nonvar(Output).

attempt(getVars(Vars),Vars):-!.
trial(getVars(Vars),Vars):-!.

attempt(true,_Vars):-!,write_debug(trace,true).
attempt(!,_Vars):-!,write_debug(trace,!).

/*
attempt(Goal,_Vars):-
	predicate_property(Goal,_),Goal,
	write_debug(trace,Goal).
*/
expanded_clause(Head,Body):-get_clauses(Head,Body,_).

attempt(Goal,_Vars):-
	get_clauses(Goal,Expand,_),!,
	write_debug(trace,expand(Goal,Expand)),
	attempt(Expand,_Vars).

get_clauses(Head,Body,1):-
	predicate_property(Head,number_of_clauses(1)),!,
	clause(Head,Body).

get_clauses(Head,(Body1;Body2),1):-!,
	get_clause(Head,Body1,1),
	get_clauses(Head,Body2,2).

get_clauses(Head,(Body1;Body2),X):-integer(X),X>1,
	get_clause(Head,Body1,X),X1 is X + 1,
	get_clauses(Head,Body2,X1),!.
	
get_clauses(Head,Body,X):-!,integer(X),X>1,
	get_clause(Head,Body,X).

get_clause(Head,Body,Index):-!,
	nth_clause(Head,Index,Ref),
	clause(Head,Body,Ref).

trial(Goal,_Vars):-
	predicate_property(Goal,_).

attempt(Goal,_Vars):-
	catch(
		Goal,
		Error,
		on_err(Error)
	),
	write_debug(trace,success(Goal)).

on_err(error(existence_error(procedure, Pred),_)):-!,
	ask_about(Pred),
	write_debug(trace,learn(Pred)),
	fail.

on_err(Error):-!,write_debug(trace,Error),fail.

ask_about(Question):-post(["i do not understand ",Question]).

	
/* make term P_Answer into conjuntive list P_Answer_List */
	%term_to_codelist(P_Answer,P_Answer_List),
	
	/* Next we need to to have some usable Knowlege Base Data */
	/* Let merge that in as well... (this data is unlimited actualy) */
	/* Thats what makes this program unique (see use_network_kernel.c) */
	/* but this unlimited database might be too much for P_Answer_Plus */
	/* well just lets grab some previously cached network Q&A */
%	get_previously_cached_network_data(Cached_Net),
	
	/* we add our goal in front of the data  	*/
%	P_Answer_Plus_Plus=(Cached_Net,P_Answer_Plus),

	/* ok we have a list Datatype Now all or execution will be on a list */
	
	/* succeed if we can trace P_Answer_Plus_Plus to Goal */
	/*          (which we weakly bind to true)     */
/*
	((Goal=true);true),
*/	
	/* in the worst case it will be lazy and bind Goal to true */
	/*                                                 */
	/*             Make a "proof tree"                 */
	/* 						   */
	/*						   */
/*
	succeed(P_Answer_Plus_Plus,Goal,Proof_Tree,RulesUsed),
*/	
	/* program is quite busy at this point */
	
	/* when its done .. it will msg the "solution" for now */
/*
	write_debug(trace,
	succeed(P_Answer_Plus_Plus,Goal,Proof_Tree,RulesUsed)).
*/
		/* and now it loops back to the top of main */
	
	/* is alot more..:).. i am finishing up the proof compilier */
:-dynamic(get_previously_cached_network_data/1).

	get_previously_cached_network_data(true).


:-dynamic(varTable/2).
varTable('Poo',poo).

unify_Globals([]):-!.
unify_Globals(VarsIN):-
        checklist(unify_Globals1,VarsIN).

clearVar(Var):-retractall(varTable(Var,_)).
unboundVar(Var):-asserta(varTable(Var,_Unbound)).

unify_Globals1(Var=Val):-
	(	
	varTable(Var,Val),write_debug(trace,varTable(Var,Val))
	);
	(
	nonvar(Var),nonvar(Val),asserta(varTable(Var,Val)),
		write_debug(trace,asserta(varTable(Var,Val)))
	);
	(
	true %Var=Val,write_debug(trace,Var=Val)
	).

:-op(700,xfx,':=').

':='(Var,Val):-catch(Enum is Val,_,Enum=Val),nonvar(Var),
	asserta(varTable(Var,Val)).

:-op(700,xfx,':==').

':=='(Var,Val):-nonvar(Var),clearVar(Var),asserta(varTable(Var,Val)).


/*	answer_templates(P_Answer,P_AnswerT),*/

  /* post parser */
        	
	/* having 4 differrent Formated Calls Now.. lets log */

		/* ok lets thread these calls */


/*
	ok_lets_try_it_out(P_Answer,Result),post(Result))
	
	catch(Reformated_Answer,_,
                (ok_lets_try_it_out(P_Answer,Result),post(Result))).


*/
/* strange tcl and network messages can come via eggdrop:egg_term/2
   this is how we handle them.. they are not for us yet */

putlog(Weird_Stuff):-write_debug(minor,Weird_Stuff).

write_debug(trace,Message):-!,
        any_to_string([trace,Message],S),
	chars_to_atom(S,A),
	msg("0",A).

	% writeq(A),nl,ttyflush.

write_debug(Level,Message):-!,
	once(debug_to(Level,Place)),!,
	msg(Place,[Level,Message]),!.

:-dynamic(debug_to/2).
debug_to(interesting,"nephrael").
debug_to(_,"nephrael").

/* Most Predicates as "Dynamic" will be dumped into the "saved_states_file.pro"
   They are changed runtime and do just as good in an external database */

:-dynamic(ignore_it/1). /* ppl and source buffers DB predicates we ignore */
	ignore_it("jerks").
	ignore_it("#lamers").

:-dynamic(have_need_for/2). /* this system will stack unfulled commands here */
	have_need_for(step4,post("you are seeing this because step4 just complete")).

:-dynamic(goal_chain/2). /* these are execution lists to do */
	goal_chain(chain_name,[step1,step2,step3,step4]).
	goal_chain(succeed_now,[true]).

:-dynamic(answer_templates/2). /* this is used to see if arg1 is needed to be reformated */
	answer_templates(Unify_left_and_right,Unify_left_and_right).

:-dynamic(user_attribute/2).
	user_attribute("nephrael",_).
	user_attribute("nephryel",_).
	user_attribute("screwedup@jupe",prolog).
	user_attribute("screwedup",prolog).

	user_attribute(User,"#ai"):-member(User,["Phantal0o","c9",[_|"ie`"],[_|"otivez"],_,
		[_|"agos"],[_|"rbitz"],[_|"ispbliss"],[_|"sk"],
		[113,120|_],"rakta",[_|"yberTech"],[108,105,115,122|_]]).
        user_attribute(User,"#prolog"):-member(User,["Phantal0o","c9",[_|"ie`"],[_|"otivez"],_,
                [_|"agos"],[_|"rbitz"],[_|"ispbliss"],[_|"sk"],
                [113,120|_],"rakta",[_|"yberTech"],[108,105,115,122|_]]).



:-dynamic(good_source_of_learning/1). /* use these resource ("0"=network) */
	good_source_of_learning(Handle):-member(Handle,["nephrael","#ai","0","#lisp","#linux","#prolog"]).


:-dynamic(security_check/3). /* ACLs? */
	security_check(Place,Who,_Cmd):-!,
		(good_source_of_learning(Place),!;good_source_of_learning(Who)),
        	(user_attribute(Who,prolog),!;user_attribute(Who,Place)),
        	not(ignore_it(Who)),
		not(ignore_it(Place)),!.

:-dynamic(functcode/2).
	functcode(my_neg_add(A,B),[C is (A+B),return(-C)]).

lets_try_new_syntax(_,_):-!,fail.

lets_try_new_syntax(_P_Answer_Atom,said(Words)):-any_to_words(_P_Answer_Atom,Words).

ok_lets_try_it_out(Goal,true):-catch(Goal,_,fail).

ok_lets_try_it_out(P_Answer,Result):-
	is_it_system(P_Answer),!, /* yes! */
	use_the_system_then(P_Answer,Result).
 
ok_lets_try_it_out(P_Answer,Result):-
	not(is_it_system(P_Answer)),
	from_my_network(P_Answer),!, /* including C code */
	use_my_network(P_Answer,Result).

ok_lets_try_it_out(P_Answer,Result):-
	waiting_for_this(P_Answer),!,
	satisfy_something(P_Answer,Result).

ok_lets_try_it_out(P_Answer,Result):-
	not(is_it_system(P_Answer)),
	write_debug(learning,["new goal: ",P_Answer]),
	create_new_goal(P_Answer,Result).

is_it_system(P_Answer):-predicate_property(P_Answer,_),!.
is_it_system(P_Answer):-functcode(P_Answer,_),!.

:-op(800,xfy,':=:').

calleval(X):-my_system(X,Y),term_to_atom(Y,Z),post(Z).

my_system([nop],[]).
my_system([],[]):-!.
my_system([X|More],Final):-my_system(X,ReducedX),my_system([ReducedX|More],Final),!.
my_system([X|More],[Y|Final]):-my_system(X,Y),my_system(More,Final).
my_system(X,X):-integer(X),!.
my_system(eval(X),Y):-my_system(X,Y),!.
my_system(X,Y):-catch((Y is X),_,fail),!.
my_system(head([X|_]),X):-!.
my_system(tail([_|Y]),Y):-!.
my_system([X|More],[Y|Final]):-my_system(X,Y),my_system(More,Final).
my_system(A,A).


use_the_system_then((Step1,MoreSteps),Result):- 
	/* Conjunctive Compile */
        ok_lets_try_it_out(Step1,MoreSteps),
        ok_lets_try_it_out(MoreSteps,Result).

use_the_system_then((Step1;MoreSteps),Result):- /* Disjunctive Compile */
        ok_lets_try_it_out(Step1,MoreSteps);
        ok_lets_try_it_out(MoreSteps,Result).

use_the_system_then(X,Y):-my_system(X,Y).
use_the_system_then(true,_):-!.
use_the_system_then(return(Thread),Thread):-nonvar(Thread),!. /* No walking backwards */
use_the_system_then(write(Mesg),side_effects):-post(Mesg).
use_the_system_then(display(Term),side_effets):-nonvar(Term),!,
	term_to_atom(Term,Mesg),
	post(Mesg).
use_the_system_then(write_debug(Place,Mesg),side_effects):-!,write_debug(Place,Mesg).
use_the_system_then(prolog,true):-!.
use_the_system_then(Really_System,_):-catch(Really_System,Error,
			(write_debug(urgent,
			["Really_System: ",Really_System,Error]),
			fail)).

from_my_network(net_call(Request)):-is_it_system(Request).
from_my_network(net_result(Result,_Bindings)):-waiting_for_this(Result).

use_my_network(net_call(Request),true):-
	use_the_system_then(Request,Result),
	send_to_network(net_result(Request,Result)).

use_my_network(net_result(Result,Bindings)):-
	satisfy_something(Result,Bindings).

waiting_for_this(Answer):-have_need_for(Answer,_),!.

satisfy_something(Answer,Result):-
	have_need_for(Answer,Midpoint),
	ok_lets_try_it_out(Midpoint,Result),
	assertz(had_need_for(Answer,Midpoint)),
	retract(have_need_for(Answer,Midpoint)).

create_new_goal(Goal,So_I_Can_Proceed_At_This):-
	create_template(Goal,So_I_Can_Proceed_At_This),
	query_all_resource(Goal,So_I_Can_Proceed_At_This).
	
create_template(Goal,So_I_Can_Proceed_At_This):-  /* aready created, */
	have_need_for(Goal,So_I_Can_Proceed_At_This),!,
	write_debug(learning,[need,Goal,to,satisfiy,So_I_Can_Proceed_At_This]).

create_template(Goal,So_I_Can_Proceed_At_This):-
	asserta(have_need_for(Goal,So_I_Can_Proceed_At_This)),
	write_debug(learning,[need,Goal,to,satisfiy,So_I_Can_Proceed_At_This]).

query_all_resource(Goal,So_I_Can_Proceed_At_This):-
	query_each_resource(Goal,So_I_Can_Proceed_At_This).
query_all_resource(_Goal,_So_I_Can_Proceed_At_This).
	
query_each_resource(Goal,_So_I_Can_Proceed_At_This):-
	good_source_of_learning(Resource),
	locate_resource(Resource,Locate),
	msg(Locate,net_call(Goal)),fail.
	
locate_resource(Try_Calling_It_By_Its_Name,Try_Calling_It_By_Its_Name).

/*
:-dynamic(have_need_for/2). /* this system will stack unfulled commands here */
        have_need_for(step4,post("you are seeing this because step4 just complete")).

:-dynamic(goal_chain/2). /* these are execution lists to do */
        goal_chain(chain_name,[step1,step2,step3,step4]).

*/
/*
	
find_out_about(Goal,So_I_Can_Proceed_At_This):-
        create_need_for(Goal,So_I_Can_Proceed_At_This),
        ask_about_goal(Goal,So_I_Can_Proceed_At_This),
        create_need_for(Goal,So_I_Can_Proceed_At_This).

fail.


*/
	
/*	have_i_been_looking_for_this(P_Answer,I_Was_Wow),
	cann_someone_do_this_for_me(Possible
	(answer_templates(P_Answer,callback(Goal,Answer)),
        retract(have_need_for(Goal,So_I_Can_Do_This_Now)),
        assert((Goal:-Answer)),
        msg(Place,["thankyou, now I can try..",So_I_Can_Do_This_Now]),
        callt(So_I_Can_Do_This_Now)).
*/
```` `
